import {
    FlywayBaselineResponse,
    FlywayCleanResponse,
    FlywayErrorResponse,
    FlywayInfoResponse,
    FlywayMigrateResponse, FlywayRepairResponse, FlywayResponse,
    FlywayValidateResponse, ParsedFlywayResponse
} from "./responses";
import {getLogger} from "../utility/logger";


// Generated by quicktype.io - can be improved to use an enum referring to the types rather than ("")
export class ConvertJsonToResponse {

    private static readonly logger = getLogger("ConvertJsonToResponse");

    public static toFlywayResponse<T extends FlywayResponse>(json: string, reference: string, properties: any): ParsedFlywayResponse<T> {
        const response: ParsedFlywayResponse<T> = {};

        try {
            const error: any = cast(JSON.parse(json), toReference("FlywayErrorWrapper"));

            if(error.error) {
                response.error = error.error;
            }
        }
        catch (err) {
            ConvertJsonToResponse.logger.log(err);
            if (err instanceof SyntaxError) {
                ConvertJsonToResponse.logger.log(json);
            } 
        }


        try {
            const flywayResponse: T = removeProperties(
                cast(JSON.parse(json), toReference(reference)),
                mapToPropertyNames(properties)
            );

            if(flywayResponse) {
                response.flywayResponse = flywayResponse;
            }
        }
        catch (err) {
            ConvertJsonToResponse.logger.log(err);
        }


        return this.handleParsingError(response);
    }


    public static toFlywayMigrateResponse(json: string): ParsedFlywayResponse<FlywayMigrateResponse> {
        return ConvertJsonToResponse.toFlywayResponse(
            json,
            "FlywayMigrateResponse",
            typeMapProperties.FlywayMigrateResponse
        );
    }

    public static toFlywayCleanResponse(json: string): ParsedFlywayResponse<FlywayCleanResponse> {
        return ConvertJsonToResponse.toFlywayResponse(
            json,
            "FlywayCleanResponse",
            typeMapProperties.FlywayCleanResponse
        );
    }

    public static toFlywayInfoResponse(json: string): ParsedFlywayResponse<FlywayInfoResponse> {
        return ConvertJsonToResponse.toFlywayResponse(
            json,
            "FlywayInfoResponse",
            typeMapProperties.FlywayInfoResponse
        );
    }

    public static toFlywayValidateResponse(json: string): ParsedFlywayResponse<FlywayValidateResponse> {
        return ConvertJsonToResponse.toFlywayResponse(
            json,
            "FlywayValidateResponse",
            typeMapProperties.FlywayValidateResponse
        );
    }

    public static toFlywayBaselineResponse(json: string): ParsedFlywayResponse<FlywayBaselineResponse> {
        return ConvertJsonToResponse.toFlywayResponse(
            json,
            "FlywayBaselineResponse",
            typeMapProperties.FlywayBaselineResponse
        );
    }

    public static toFlywayRepairResponse(json: string): ParsedFlywayResponse<FlywayRepairResponse> {
        return ConvertJsonToResponse.toFlywayResponse(
            json,
            "FlywayRepairResponse",
            typeMapProperties.FlywayRepairResponse
        );
    }



    private static handleParsingError<T extends FlywayResponse>(response: ParsedFlywayResponse<T>): ParsedFlywayResponse<T> {
        if(response.flywayResponse == undefined && response.error == undefined) {
            return {
                error: {
                    errorCode: "UNABLE_TO_PARSE_RESPONSE",
                    message: "Command successful but unable to parse Flyway response."
                }
            }
        }
        return response;
    }

}

function mapToPropertyNames(_object: any[]): string[] {
    return _object.map(property => property.js);
}

function removeProperties(_object: any, propertiesToKeep: string[]) {
    const objectWithPropertiesRemoved = Object.assign({}, _object);
    for( let property in objectWithPropertiesRemoved) {
        if(!propertiesToKeep.includes(property)) {
            delete objectWithPropertiesRemoved[property];
        }
    }
    return objectWithPropertiesRemoved;
}

function invalidValue(typ: any, val: any, key: any = ''): never {
    if (key) {
        throw Error(`Invalid value for key "${key}". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`,);
}

function jsonToJSProps(typ: any): any {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function transform(val: any, typ: any, getProps: any, key: any = ''): any {
    function transformPrimitive(typ: string, val: any): any {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs: any[], val: any): any {
        // val must validate against one typ in typs

        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) { }
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases: string[], val: any): any {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ: any, val: any): any {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) {
            if (val === null || val === undefined) {
                return val;
            }
            return invalidValue("array", val);
        }
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val: any): any {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue("Date", val);
        }
        return d;
    }

    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {
        if (val === null || typeof val !== "object" || Array.isArray(val)) {
            return invalidValue("object", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = val[key];
            }
        });
        return result;
    }

    if (typ === "any") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === "object" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === "object") {
        return typ.hasOwnProperty("unionMembers") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty("arrayItems") ? transformArray(typ.arrayItems, val)
                : typ.hasOwnProperty("props") ? transformObject(getProps(typ), typ.additional, val)
                    : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== "number") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val: any, typ: any): T {
    return transform(val, typ, jsonToJSProps);
}

function toArray(typ: any) {
    return { arrayItems: typ };
}

function toUnion(...typs: any[]) {
    return { unionMembers: typs };
}

function toObject(props: any[], additional: any) {
    return { props, additional };
}

function toReference(name: string) {
    return { ref: name };
}

/*
    TODO - update this to handle nested properties and update delete
 */
const typeMapProperties: any = {
    FlywayErrorWrapper: [
        { json: "error", js: "error", typ: toUnion(toReference("FlywayError"), undefined, null) }
    ],
    FlywayErrorResponse: [
        { json: "errorCode", js: "errorCode", typ: toUnion("", undefined, null) },
        { json: "message", js: "message", typ: toUnion("", undefined, null) },
        { json: "stackTrace", js: "stackTrace", typ: toUnion("", undefined, null) }
    ],
    FlywayMigrateResponse: [
        {json: "initialSchemaVersion", js: "initialSchemaVersion", typ: toUnion("", undefined, null)},
        {json: "targetSchemaVersion", js: "targetSchemaVersion", typ: toUnion("", undefined, null)},
        {json: "schemaName", js: "schemaName", typ: ""},
        {json: "migrations", js: "migrations", typ: toArray(toReference("FlywayMigrateResponseMigration"))},
        {json: "migrationsExecuted", js: "migrationsExecuted", typ: 0},
        {json: "flywayVersion", js: "flywayVersion", typ: ""},
        {json: "database", js: "database", typ: ""},
        {json: "warnings", js: "warnings", typ: toArray("any")},
        {json: "operation", js: "operation", typ: ""}
    ],
    FlywayMigrateResponseMigration: [
        { json: "category", js: "category", typ: "" },
        { json: "version", js: "version", typ: "" },
        { json: "description", js: "description", typ: "" },
        { json: "type", js: "type", typ: "" },
        { json: "filepath", js: "filepath", typ: "" },
        { json: "executionTime", js: "executionTime", typ: 0 },
    ],
    FlywayCleanResponse: [
        { json: "schemasCleaned", js: "schemasCleaned", typ: toArray("") },
        { json: "schemasDropped", js: "schemasDropped", typ: toArray("") },
        { json: "flywayVersion", js: "flywayVersion", typ: "" },
        { json: "database", js: "database", typ: "" },
        { json: "warnings", js: "warnings", typ: toArray("any") },
        { json: "operation", js: "operation", typ: "" }
    ],

    FlywayInfoResponse: [
        { json: "schemaVersion", js: "schemaVersion", typ: toUnion("", undefined, null) },
        { json: "schemaName", js: "schemaName", typ: "" },
        { json: "migrations", js: "migrations", typ: toArray(toReference("FlywayInfoResponseMigration")) },
        { json: "allSchemasEmpty", js: "allSchemasEmpty", typ: true },
        { json: "flywayVersion", js: "flywayVersion", typ: "" },
        { json: "database", js: "database", typ: "" },
        { json: "warnings", js: "warnings", typ: toArray("any") },
        { json: "operation", js: "operation", typ: "" }
    ],

    FlywayInfoResponseMigration: [
        { json: "category", js: "category", typ: "" },
        { json: "version", js: "version", typ: "" },
        { json: "description", js: "description", typ: "" },
        { json: "type", js: "type", typ: "" },
        { json: "installedOnUTC", js: "installedOnUTC", typ: "" },
        { json: "state", js: "state", typ: "" },
        { json: "undoable", js: "undoable", typ: "" },
        { json: "filepath", js: "filepath", typ: "" },
        { json: "undoFilepath", js: "undoFilepath", typ: "" },
        { json: "installedBy", js: "installedBy", typ: "" },
        { json: "executionTime", js: "executionTime", typ: 0 },
    ],

    FlywayValidateResponse: [
        { json: "errorDetails", js: "errorDetails", typ: toUnion(toReference("FlywayValidateResponseErrorDetails"), undefined, null) },
        { json: "invalidMigrations", js: "invalidMigrations", typ: toArray(toReference("FlywayValidateResponseMigration")) },
        { json: "validationSuccessful", js: "validationSuccessful", typ: true },
        { json: "validateCount", js: "validateCount", typ: 0 },
        { json: "flywayVersion", js: "flywayVersion", typ: "" },
        { json: "database", js: "database", typ: "" },
        { json: "warnings", js: "warnings", typ: toArray("any") },
        { json: "operation", js: "operation", typ: "" }
    ],

    FlywayValidateResponseMigration: [
        { json: "version", js: "version", typ: "" },
        { json: "description", js: "description", typ: "" },
        { json: "filepath", js: "filepath", typ: "" },
        { json: "errorDetails", js: "errorDetails", typ: toReference("FlywayValidateResponseErrorDetails") }
    ],

    FlywayValidateResponseErrorDetails: [
        { json: "errorCode", js: "errorCode", typ: "" },
        { json: "errorMessage", js: "errorMessage", typ: "" }
    ],

    FlywayBaselineResponse: [
        { json: "successfullyBaselined", js: "successfullyBaselined", typ: true },
        { json: "baselineVersion", js: "baselineVersion", typ: ""},
        { json: "flywayVersion", js: "flywayVersion", typ: "" },
        { json: "database", js: "database", typ: "" },
        { json: "warnings", js: "warnings", typ: toArray("any") },
        { json: "operation", js: "operation", typ: "" },
    ],

    FlywayRepairResponse: [
        { json: "repairActions", js: "repairActions", typ: toArray("") },
        { json: "migrationsRemoved", js: "migrationsRemoved", typ: toArray(toReference("FlywayRepairResponseMigration")) },
        { json: "migrationsDeleted", js: "migrationsDeleted", typ: toArray(toReference("FlywayRepairResponseMigration")) },
        { json: "migrationsAligned", js: "migrationsAligned", typ: toArray(toReference("FlywayRepairResponseMigration")) },
        { json: "flywayVersion", js: "flywayVersion", typ: "" },
        { json: "database", js: "database", typ: "" },
        { json: "warnings", js: "warnings", typ: toArray("any") },
        { json: "operation", js: "operation", typ: "" },
    ],

    FlywayRepairResponseMigration: [
        { json: "version", js: "version", typ: "" },
        { json: "description", js: "description", typ: "" },
        { json: "filepath", js: "filepath", typ: "" },
    ]

};


const typeMap: any = {
    // Flyway Error
    "FlywayErrorWrapper": toObject(typeMapProperties.FlywayErrorWrapper, false),
    "FlywayError": toObject(typeMapProperties.FlywayErrorResponse, false),
    // Flyway Migrate Response
    "FlywayMigrateResponse": toObject(typeMapProperties.FlywayMigrateResponse, false),
    "FlywayMigrateResponseMigration": toObject(typeMapProperties.FlywayMigrateResponseMigration, false),
    // Flyway Clean Response
    "FlywayCleanResponse": toObject(typeMapProperties.FlywayCleanResponse, false),
    // Flyway Info Response
    "FlywayInfoResponse": toObject(typeMapProperties.FlywayInfoResponse, false),
    "FlywayInfoResponseMigration": toObject(typeMapProperties.FlywayInfoResponseMigration, false),
    // Flyway Validate Response
    "FlywayValidateResponse": toObject(typeMapProperties.FlywayValidateResponse, false),
    "FlywayValidateResponseMigration": toObject(typeMapProperties.FlywayValidateResponseMigration, false),
    "FlywayValidateResponseErrorDetails": toObject(typeMapProperties.FlywayValidateResponseErrorDetails, false),
    // Flyway Baseline Response
    "FlywayBaselineResponse": toObject(typeMapProperties.FlywayBaselineResponse, false),
    // Flyway Repair Response
    "FlywayRepairResponse": toObject(typeMapProperties.FlywayRepairResponse, false),
    "FlywayRepairResponseMigration": toObject(typeMapProperties.FlywayRepairResponseMigration, false),


};